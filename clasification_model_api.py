# -*- coding: utf-8 -*-
"""clasification_model_api.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sILIVnVf3MgunUBJTfdtP_FnvgdqNDO4
"""

!pip install h5py

!pip install librosa

!pip install resampy

!pip install Flask

import numpy as np
import librosa
from tensorflow.keras.models import load_model
from sklearn.preprocessing import LabelEncoder
from keras.utils import to_categorical
import pandas as pd

# Load the saved model
model = load_model('/content/drive/MyDrive/frog calls/frog_classification.h5')

# Define a function to preprocess audio similar to your training data
def preprocess_audio(audio_path):
    audio, sample_rate = librosa.load(audio_path, res_type='kaiser_fast')
    mfccs_features = librosa.feature.mfcc(y=audio, sr=sample_rate, n_mfcc=40)
    mfccs_scaled_features = np.mean(mfccs_features.T, axis=0)
    return mfccs_scaled_features

# Path to the audio file you want to classify
audio_file_path = '/content/drive/MyDrive/frog calls/abcd/common shrub frog/Common Shrub Frog_ (100).wav'

# Preprocess the input audio
input_features = preprocess_audio(audio_file_path)
input_features = np.expand_dims(input_features, axis=0)  # Add a batch dimension

# Load the class labels from your CSV file or use the same labels used in training
metadata = pd.read_csv('/content/drive/MyDrive/frog calls/Untitled folder1/csv/Book1.csv')
class_labels = metadata['Species'].unique()

# Create a label encoder and fit it with the class labels
labelencoder = LabelEncoder()
labelencoder.fit(class_labels)

# Make predictions using the loaded model
predictions = model.predict(input_features)

# Inverse transform the label encoding to get the predicted class
predicted_class = labelencoder.inverse_transform(np.argmax(predictions, axis=1))

if predicted_label == 0:
    print("Predicted Class:", predicted_class)
    print("Class of the frog is: Indian Skipper Frog")
elif predicted_label == 1:
    print("Predicted Class:", predicted_class)
    print("Class of the frog is: Common Shrub Frog")
elif predicted_label == 2:
    print("Predicted Class:", predicted_class)
    print("Class of the frog is: Stream lined Frog")

import os
import numpy as np
from flask import Flask, request, jsonify
from tensorflow.keras.models import load_model
import librosa
import librosa.display

app = Flask(__name)

# Load the trained model
model_path = '/content/drive/MyDrive/frog calls/frog_classification.h5'
loaded_model = load_model(model_path)

# Load the label encoder
from sklearn.preprocessing import LabelEncoder
labelencoder = LabelEncoder()
# Load label encoder classes
labelencoder.classes_ = np.load('/content/drive/MyDrive/frog calls/classes.npy')

def preprocess_audio(file_path):
    audio, sample_rate = librosa.load(file_path, res_type='kaiser_fast')
    mfccs_features = librosa.feature.mfcc(y=audio, sr=sample_rate, n_mfcc=40)
    mfccs_scaled_features = np.mean(mfccs_features.T, axis=0)
    return mfccs_scaled_features

@app.route('/classify-audio', methods=['POST'])
def classify_audio():
    if 'audio' not in request.files:
        return jsonify({"error": "No audio file provided"})

    audio_file = request.files['audio']

    if audio_file.filename == '':
        return jsonify({"error": "Empty audio file name"})

    try:
        # Preprocess the audio
        audio_features = preprocess_audio(audio_file)

        # Reshape the features to match the model input shape
        audio_features = audio_features.reshape(1, -1)

        # Make predictions using the loaded model
        predictions = loaded_model.predict(audio_features)

        # Get the predicted class label
        predicted_class = labelencoder.inverse_transform([np.argmax(predictions)])[0]

        return jsonify({"predicted_class": predicted_class})
    except Exception as e:
        return jsonify({"error": str(e)})

if __name__ == "__main__":
    app.run(host='0.0.0.0', port=5000, debug=True)